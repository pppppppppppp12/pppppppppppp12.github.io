<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git hooks无法pre-commit的问题]]></title>
    <url>%2F2019%2F10%2F30%2Fgit-hooks%E6%97%A0%E6%B3%95pre-commit%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题新构建的antd-pro项目，hooks无法执行pre-commit。在npm run lint-staged检测报错的情况下，git commit没有执行pre-commit钩子，直接提交成功。 原因husky要求git版本在2.13.0以上，git版本过低会使husky设置git hooks失败，导致commit跳过了pre-commit，下图为报错信息： husky安装时设置git hooks失败 解决升级git版本，重新执行cnpm install husky。 资料：mac下git升级到最新版本antd-pro issueshusky issues]]></content>
      <tags>
        <tag>antd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvc模式与数据绑定的方式]]></title>
    <url>%2F2019%2F03%2F11%2Fmvc%2F</url>
    <content type="text"><![CDATA[前言页面渲染方式： 服务端渲染，如smarty后端模板 利于seo 渲染速度更快 浏览器端渲染，前端模板 减少维护成本 提高效率，前后端分离的合作模式 模板引擎工作原理： 模板解析 / 编译 parse / compile 数据渲染 render String-based，基于string的parse和compile过程 本质上是字符串拼接的形式，遍历html字符串 基于正则表达式查找出模板 { { } } es6模板字符串 替换模型数据，实现视图渲染，依赖于innerHTML 典型库 art-template mustache.js doT Dom-based，基于dom的link或compile过程 遍历dom树节点属性和子节点，渲染render 提取dom中的{ { } }关键词，替换数据模型 基于mvc结构：模板视图，数据模型，引擎函数作为控制器实现数据与视图的绑定 数据模型更新 -&gt; 视图更新：双向绑定。局部渲染更新 典型库 Angular 脏检测，在特定事件下触发视图刷新 React 虚拟dom算法检查dom变化 Vue2 Getter/Setter机制与虚拟dom avalonjs 数据双向绑定的实现 监听vue实例中data属性，遍历此对象的属性，并使用Object.defineProperty 把这些属性转为getter/setter 1234567891011121314151617181920var obj = &#123; a: 1&#125;// a,b属性值互相依赖，更容易监听对象的变化Object.defineProperty(obj, "b", &#123; // 对象，属性，属性描述符 get: function () &#123; return this.a + 1 &#125;, set: function (value) &#123; this.a = value / 2 &#125;&#125;)// 更新 obj.aobj.a = 3console.log(obj.a) // 3console.log(obj.b) // 4// 更新 obj.bobj.b = 10console.log(obj.a) // 5console.log(obj.b) // 6 数据描述符 可写 / 不可写 属性描述符 存取描述符 getter / setter Living templating，基于string的parse和基于dom的compile过程 htmlbar ractivejs regularjs]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+webpack环境构建及依赖插件]]></title>
    <url>%2F2019%2F03%2F06%2Fwebpack%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言基于vue-cli3搭建基础的项目架构，针对不同的环境进行构建配置：本地环境，测试环境，线上环境。下面是对不同环境的一些配置和依赖工具的说明。 本地环境命令1234// vue-cli升级到2.9.1后，webpack升级到3.6.0，改成使用webpack.dev.conf.js配置// node build/dev-server.jscnpm run devwebpack-dev-server --inline --progress --config build/webpack.dev.conf.js 配置 webpack-dev-server hot 开启热更新 proxyTable 配置接口地址代理，解决接口跨域问题 webpack.dev.conf.js 12345678910111213141516171819202122// webpack服务器配置 devServer: &#123; clientLogLevel: 'warning', // 消息类型 none error warning info historyApiFallback: &#123; // 404响应，替代为index.hmtl rewrites: [ &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') &#125;, ], &#125;, hot: true, // 热更新开启 contentBase: false, // since we use CopyWebpackPlugin. compress: true // 启用gzip压缩 host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, // true 是否自动打开浏览器 overlay: config.dev.errorOverlay // true 编译错误是是否全屏覆盖 publicPath: config.dev.assetsPublicPath, // '/' proxy: config.dev.proxyTable, // 接口请求代理到后端服务器地址 quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; // 获取文件更新通知 poll: config.dev.poll, // false 是否使用轮询 &#125; &#125;, config/index.js 1234567// 'http://localhost:8080/auth' ==&gt; 'http://localhost:8889/auth'proxyTable: &#123; '/auth':&#123; target: 'http://localhost:8889', // 目标接口域名 changeOrigin: true // 是否跨域 &#125;,&#125; 测试环境命令12cnpm run build_testnode build/build-test.js 配置 config/index.js 123456789101112131415161718build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist'), // 输出目录 assetsSubDirectory: 'static', assetsPublicPath: '/', /** * Source Maps */ productionSourceMap: false, devtool: '#source-map', cssSourceMap: true, // 压缩 productionGzip: false, productionGzipExtensions: ['js', 'css'], bundleAnalyzerReport: process.env.npm_config_report, &#125; 正式环境命令12cnpm run buildnode build/build.js 配置 config/index.js map选项设置为false 123productionSourceMap: false,devtool: '#source-map',cssSourceMap: false, koa后端1234cnpm run servernode app.jscnpm run server_watch // 监听文件更新，自动重启应用nodemon app.js 通用工具check-versions 检测node和npm版本 版本配置，package.json 123456&#123; "engines": &#123; "node": "&gt;= 7.6.0", "npm": "&gt;= 3.0.0" &#125; &#125; 依赖模块 chalk 控制台高亮 semver 判断版本号 shelljs 执行Unix命令 child_process 新建子进程，执行命令 环境参数配置 依赖模块 webpack-merge拆分与合并配置对象 webpack.DefinePlugin({‘process.env’: config.build.env}) 设置环境参数 devtool 开发工具配置，代码调试定位，”cheap-module-eval-source-map” 调试工具 compression-webpack-plugin 正式环境压缩 浏览器兼容性 浏览器兼容性版本配置 1234567&#123; "browserslist": [ "&gt; 1%", "last 2 versions", "not ie &lt;= 8" ] &#125; 依赖模块 Babel/preset-env 兼容js特性 postcss 添加浏览器前缀 postcss-loader，配合使用Autoprefixer css浏览器前缀 html和静态资源123456789101112131415161718192021// 生成html文件，并注入资源链接new HtmlWebpackPlugin(&#123; filename: config.build.index, template: 'index.html', inject: true, favicon: path.join(__dirname, '../', 'src/assets/favicon.ico'), minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: 'dependency'&#125;),// 复制静态资源文件new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125;]) 依赖模块 html-webpack-plugin 生成html，注入资源链接 copy-webpack-plugin 文件复制到构建目录，通常是static下的库文件，对应配置项 assetsSubDirectory: &#39;static&#39; url-loader 将小的静态资源文件转化为base64，减少http请求数量 css12345678910// 分离css文件new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash].css')&#125;),// 压缩css文件new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125;&#125;), 依赖模块 vue-loader css-loader extract-text-webpack-plugin 分离css文件 optimize-css-assets-webpack-plugin 压缩css文件 vue-style-loader less 预处理器 less-loader js1234567891011121314151617181920212223242526// 压缩js文件new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125;, sourceMap: false&#125;),// 提取公共代码，公共模块打包到vendornew webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module, count) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ) &#125;&#125;),// 提取公共代码，将业务代码打包到manifestnew webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', chunks: ['vendor']&#125;), 依赖模块 webpack.optimize.UglifyJsPlugin webpack.optimize.CommonsChunkPlugin vue-loader babel-loader -&gt; 支持es6，import、export require() style-loader 作用域 scoped、module 支持与处理器 less-loader postcss、autoprefixer 浏览器兼容前缀 api]]></content>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue性能优化与代码风格]]></title>
    <url>%2F2019%2F02%2F25%2Fvue-%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[性能 v-for设置key可复用元素，更新dom时，可根据key来识别唯一元素是否可复用，把dom变动成本降到最低 v-if和v-for避免用在同一个元素上，减少遍历运算成本和渲染成本 过滤列表，将列表作为计算属性返回 显示隐藏状态，将v-if移至父容器 路由懒加载 异步组件 1234567891011// Foo.vueconst Foo = () =&gt; Promise.resolve(&#123; // ... 组件定义对象&#125;)// 引用组件，Babel需要添加 syntax-dynamic-import解析语法const Foo = () =&gt; import('./Foo.vue')const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo &#125; ]&#125;) webpack代码分割，按需加载 webpack4 -&gt; SplitChunksPlugin，配置指南 123456789101112131415161718192021222324252627module.exports = &#123; //... // 代码分离的默认配置参数 optimization: &#123; splitChunks: &#123; chunks: 'async', minSize: 30000, // vendor-chunk 大于30k maxSize: 0, minChunks: 1, maxAsyncRequests: 5, // 按需加载的代码块，并行请求数量小于等于5 maxInitialRequests: 3, // 初始加载的代码块，并行请求数量小于等于5个 automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; // 来自node_modules模块 test: /[\\/]node_modules[\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125;; 代码风格组件样式作用域 scoped module，生成的css对象注入到组件的$style计算属性 BEM约定 .block 块 .block__element 元素 .block–modifier 修饰符 1234567891011121314151617181920212223242526272829 &lt;template&gt;&lt;button class="button"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 `scoped` 特性 --&gt;&lt;style scoped&gt;.button &#123; border: none; border-radius: 2px;&#125;&lt;/style&gt;&lt;template&gt; &lt;button :class="[$style.button]"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 CSS Modules --&gt;&lt;style module&gt;.button &#123; border: none; border-radius: 2px;&#125;&lt;/style&gt;&lt;template&gt;&lt;button class="c-Button c-Button--close"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 BEM 约定 --&gt;&lt;style&gt;.c-Button &#123; border: none; border-radius: 2px;&#125;.c-Button--close &#123; background-color: red;&#125;&lt;/style&gt; 关于命名风格 推荐用 $_ 作为私有属性 单文件组件 大驼峰 横线连接 - 通用基础组件名 Base html元素 App 其他基础组件 V 第三方ui组件库 单例组件，每个页面只会使用一次 TheHeading.vue 模块中紧密耦合的组件 模块.vue 模块Item.vue 组件名使用 单文件组件、字符串模板、Jsx中 使用自闭合，大驼峰 Dom模板中 使用闭合标签，横线连接 -]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件之间的共享状态：store模式与vuex状态管理]]></title>
    <url>%2F2019%2F02%2F25%2Fvuex%2F</url>
    <content type="text"><![CDATA[特性共享状态解决以下问题： 多个组件共享状态state，如兄弟组件之间的状态传递 不同组件行为需要更新同一state，但不破坏组件之间的单向数据流 对于简单应用 store模式 集中式状态管理 action统一管理state的更新，更好地记录state的变化和调试 12345678910111213141516171819202122var store = &#123; debug: true, state: &#123; message: 'Hello!' &#125;, setMessageAction (newValue) &#123; if (this.debug) console.log('setMessageAction triggered with', newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; if (this.debug) console.log('clearMessageAction triggered') this.state.message = '' &#125; &#125;// 每个实例/组件仍然可以拥有和管理自己的私有状态var vmA = new Vue(&#123; data: &#123; // ... privateState sharedState: store.state &#125;&#125;) 对于大型应用 vuex状态管理 全局单例模式管理状态 集中式存储管理应用的所有组件的状态 store注入根实例，通过this.$store访问12345678910111213// 定义单例storeconst store = new Vuex.Store(&#123; mutations: &#123; &#125;, // 全局action modules: &#123; a: moduleA &#125;&#125;)// 注入根实例const app = new Vue(&#123; el: '#app', store, components: &#123; Counter &#125;, template: ` &lt;div class="app"&gt;&lt;/div&gt;`&#125;) modules分割模块12345678910// 定义store模块const moduleA = &#123; state: &#123; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;&#125;// 引用this.$store.state.a // -&gt; moduleA 的状态this.$store.state.b // -&gt; moduleB 的状态 state状态 状态存储state是响应式的 通过commit提交mutation去改变状态 组件可以在计算属性中获取state12// 引用this.$store.state.module.selectState getter计算属性1234567891011121314// 定义getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125;, // 通过方法访问，并传参 getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125; // 引用this.$store.getters.doneTodos this.$store.getters.getTodoById(2) mutation 同步函数 mutation中变更state 通过 this.$store.commit(‘funName’) 提交mutation 12345678// 定义mutations: &#123; setFlag (state, params) &#123; state.count++ &#125;&#125; // 调用this.$store.commit('setFlag', params) action 异步函数 action中提交mutation变更state 通过 this.$store.dispatch() 分发action 1234567891011121314151617// 定义actions: &#123; funcname (context, params) &#123; // &#123;commit, state&#125; // context.state // context.getters context.commit('setFlag') &#125;, // 返回promise funcname2 (context) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve() &#125;).then().catch() &#125;&#125;// 调用this.$store.dispatch('funname', params)await this.$store.dispatch('funcname2')]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础指令与组件通信]]></title>
    <url>%2F2019%2F02%2F17%2Fvue-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础语法vue应用结构 根实例 12&lt;div id="app"&gt;&lt;/div&gt;new Vue(&#123; el: '#app'&#125;) 组件vue实例 12345678&lt;div id="app"&gt; &lt;btn-component&gt;&lt;/btn-component&gt;&lt;/div&gt;Vue.component('btn-component', &#123; data: function () &#123; return: &#123; count: 0 &#125; &#125;&#125;) 指令123456&lt;!--动态参数--&gt;&lt;a v-bind:[attributeName]="url"&gt;&lt;/a&gt;&lt;!--修饰符--&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!--缩写--&gt;&lt;a :href="url"&gt;&lt;/a&gt;&lt;a @click="eventname"&gt;&lt;/a&gt; v-for 列表类型 12345678&lt;!--数组--&gt;&lt;li v-for="(todo, index) in todos" :key="todo.id"&gt; &#123;&#123; index &#125;&#125;: &#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&lt;!--对象--&gt;&lt;li v-for="(value, key, index) in objs"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt; 列表响应 1234567891011121314151617181920212223242526272829303132/********* 数组 *********/ /** * 变异数组 * push pop shift unshift splice sort reverse */ this.todos.push(&#123;text: 'str', id: '111'&#125;) /** * 非变异数组 * 返回新数组，会复用dom替换原来的数组 * filter concat */ this.todos.filter(function(item) &#123; return item.text === 'str' &#125;) // 利用索引设置 this.$set(this.todos, index, newValue) this.todos.splice(index, 1, newValue) // this.todos[1] = 'x' // 不是响应性的 // 设置数组长度 this.todos.splice(newLength) // this.todos.length = 2 // 不是响应性的/********* 对象 *********/ // 响应式对象属性需要在data中添加和删除 var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125; &#125;) // 修改对象属性 this.$set(this.obj, 'name', 'str') v-model 1&lt;input v-model="message"&gt; v-on 1234567891011121314&lt;button v-on:click="reverseMessage"&gt;Reverse Message&lt;/button&gt;&lt;!--按键修饰符--&gt;&lt;button v-on:keyup.enter="reverseMessage"&gt;Reverse Message&lt;/button&gt;&lt;!--事件修饰符--&gt;&lt;!-- stop prevent capture self once passive --&gt;&lt;button v-on:click.stop="reverseMessage"&gt;Reverse Message&lt;/button&gt;&lt;!--鼠标按键修饰符 left right middle--&gt;&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact="onCtrlClick"&gt;A&lt;/button&gt; v-once 1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-html 123&lt;span&gt;&#123;&#123; commonString &#125;&#125;&lt;span&gt;&lt;!--注意防止xss攻击，只对可信内容使用html插值，或进行xss过滤--&gt;&lt;span v-html="htmlString"&gt;&lt;/span&gt; v-if 123&lt;div v-if="type === 'A'"&gt; A &lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B &lt;/div&gt;&lt;div v-else&gt; C &lt;/div&gt; 属性指令 123&lt;img :src="url"&gt;&lt;a :title="string"&gt;&lt;/a&gt;&lt;a v-bind:title="string"&gt;&lt;/a&gt; 样式，自动添加前缀 12345678910111213141516data &#123; isActive: true, isNext: false, activeClass: 'active', activeColor: 'red', fontSize: 30&#125; &lt;!--对象--&gt; &lt;div :class="&#123; active: isActive, 'next': isNext &#125;" :style="&#123; fontSize: fontSize + 'px', color: activeColor, display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"&gt; &lt;!--多重值，用于设置多前缀属性--&gt; &lt;/div&gt; &lt;!--数组--&gt; &lt;div :class="[isActive ? activeClass : '', nextClass]" :style="[&#123;color: activeColor&#125;, &#123;fontSize: fontSize + 'px'&#125;]"&gt;&lt;/div&gt; 实例数据属性 data对象 -&gt; 属性 属性值改变，视图响应 组件的data必须是个函数，使组件实例管理独立的数据 计算属性 computed对象 get、set 实例属性 $el、$data、$props、$refs $root、$children、$parent $options 自定义选项、$isServer、$listeners、$attrs 实例方法 数据 $watch、$set、$delete Vue.set() / this.$set() $watch 自定义监听器 监听属性变化并异步执行 事件 $on、$once、$off、$emit 生命周期 $mount、$forceUpdate、$nextTick、$destroy $forceUpdate 迫使实例重新渲染 $nextTick 将回调延迟到下次dom更新之后执行1234567//请求成功后 数据赋值this.goods = res.data// vue 在这个阶段才会把获取到的数据渲染完成到dom里，然后进行 dom 操作this.$nextTick(() =&gt; &#123; ...&#125;) 生命周期钩子 created、beforeCreate mounted、beforeMount updated、beforeUpdate // data change destroyed、beforeDestroy 组件组件之间的数据传递父传子 props ，props定义尽量详细1234567891011121314151617Vue.component('todo-item', &#123; props: &#123; status: &#123; type: String, required: true, validator: function (value) &#123; return [ 'syncing', 'synced', 'version-conflict', 'error' ].indexOf(value) !== -1 &#125; &#125; &#125;, template: '&lt;li&gt;这是个待办项&lt;/li&gt;' &#125;) 123456&lt;ol&gt; &lt;todo-item v-for="item in groceryList" v-bind:todo="item" v-bind:key="item.id" &gt;&lt;/todo-item&gt;&lt;/ol&gt; 子传父，v-on，$emit，监听子组件事件1234567// 父组件监听&lt;blog-post v-for="..." v-on:update:fontSize="postFontSize = $event"&gt;&lt;/blog-post&gt;// 子组件blog-post按钮&lt;button v-on:click="$emit('update:fontSize', 0.1)"&gt; btn &lt;/button&gt; .sync修饰符也可以实现12&lt;!--.sync用在字面量对象--&gt;&lt;blog-post v-bind:title.sync="postFontSize"&gt; 改变另一个组件的实例内部 vuex [大型应用]其他情况 访问根实例、父实例 $root、$parent // 小型 访问子组件实例或子元素 ref 依赖注入，与任意后代组件的属性传递 provide 指定提供给后代组件的数据/方法 inject 接收父代组件提供的指定属性 组件加载缓存组件 keep-alive123&lt;keep-alive&gt; &lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步加载12345678910Vue.component('async-webpack-example', function (resolve) &#123; // 这个特殊的 `require` 语法将会告诉 webpack// 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require(['./my-async-component'], resolve) &#125;)Vue.component( 'async-webpack-example', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component') ) 单文件组件 完整的语法高亮 commonJs 模块化管理 组件作用域的css 自动化构建步骤，使用预处理器 提高复用性混入对象 minxis Vue.minxin 全局混入 添加组件选项：new Vue({minxis: […]}) / Vue.extend({minxis: […]}) 自定义指令 Vue.directive(‘string’, {}) 钩子函数 bind (el, binding, vnode, oldVnode) 参数只读 共享数据 dataset —— data-* inserted update componentUpdated unbind 渲染 dom 节点树 虚拟dom 对真实dom的变化保持追踪 虚拟节点Vnode 插件插件类型 全局方法/属性 全局资源：自定义指令、自定义过滤器、过渡 mixin方法添加组件选项、Vue.extend() Vue实例方法 Vue.prototype 引入库 插件使用 全局方法 Vue.use() 123456Vue.use(MyPlugins)// 引入并调用vue-routervar Vue = require('vue') var VueRouter = require('vue-router')Vue.use(VueRouter) 开发插件 123456789101112131415161718// 引入单文件组件const warnTpl = require('./warnTpl.vue');// 定义插件对象const MyPlugins = &#123;&#125;;MyPlugins.install = function (Vue, options) &#123; ... // 注入组件 const warnComp = Vue.extend(warnTpl) // 添加全局方法、实例方法 Vue.$warn = Vue.prototype.$warn = (msg, time = 1000) =&gt; &#123; new warnComp(&#123; // 动态组件 propsData: &#123; msg, time &#125; &#125;).$mount() &#125;&#125;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router路由配置与使用]]></title>
    <url>%2F2019%2F02%2F17%2Fvue-router%2F</url>
    <content type="text"><![CDATA[配置参数使用路由123456789&lt;!--命令路由，导航--&gt;&lt;router-link to="/user"&gt;Go to User&lt;/router-link&gt;&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125; &#125;"&gt;Go to User&lt;/router-link&gt;&lt;!--内嵌a标签，右击有效，可控制窗口打开方式--&gt;&lt;router-link tag="li" to="/index"&gt; &lt;a href="javascript:;" target="_blank"&gt;平台首页&lt;/a&gt;&lt;/router-link&gt;&lt;!--命名视图，路由组件--&gt;&lt;router-view name="header"&gt;&lt;/router-view&gt; 路由配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import VueRouter from 'vue-router'Vue.use(VueRouter)const router = new VueRouter(&#123; mode: 'history', // 根目录下跳转，需要后端配置；默认hash模式 base: __dirname, linkActiveClass: 'active', // 全局配置 激活态类名 routes: [ &#123; path: '/first/:pid?', // ? 可选参数 component: Firstcomponent, alias: '/b' // 别名 meta: &#123; requiresAuth: true &#125; // 定义路由元信息，meta字段 &#125;, &#123; path: '/second', // / 开头的嵌套路径会被当做根路径 components: &#123; header: header, // 对应&lt;router-view&gt;的name default: main, footer: footer &#125; &#125;, &#123; path: '/user/:id', components: &#123; // 模板传参 default: &#123; template: '&lt;div&gt;' + '&lt;router-view name="innerHeader"&gt;&lt;/router-view&gt;' + '&lt;router-view&gt;&lt;/router-view&gt;' + '&lt;/div&gt;' &#125;, &#125;, children: [&#123; // 嵌套路由 // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'profile', component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts &#125;] &#125;, &#123; path: '*', // 不存在的地址 重定向 redirect: '/first' &#125; ]&#125;)// 注入路由组件new Vue(&#123; router&#125;).$mount('#app') 属性 this.$route.name // 当前路由 params.pid // 获取路由参数 hash // 获取当前url query // 查询参数 1234// 监听路由变化watch: &#123; '$route': 'callbackFun'&#125;, 方法 this.$router.push() onComplete 导航成功完成后执行 onAbort 路由相同，参数不同，使用beforeRouteUpdate响应变化12345678// 字符串router.push('home')// 对象，path情况下忽略paramsrouter.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: '123' &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) go(n) back()、go(-1) replace() beforeEach((to, from, next) =&gt; {}) 监听路由更新，跳转路由前的入口控制，可用于权限判断 to 下一个路由 from 当前路由 next next() 下一个钩子，直到next()都执行完，才确认跳转 next(false) 中断跳转 next(‘/‘) 跳转到指定路由 响应路由导航完成后获取数据created中获取，并展示loading状态123456789101112131415&lt;template&gt; &lt;div class="post"&gt; &lt;div class="loading" v-if="loading"&gt; Loading... &lt;/div&gt; &lt;div v-if="error" class="error"&gt; &#123;&#123; error &#125;&#125; &lt;/div&gt; &lt;div v-if="post" class="content"&gt; &lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 导航完成前获取数据beforeEach，获取后next() 路由懒加载 异步组件、 webpack代码分割1234567891011// Foo.vueconst Foo = () =&gt; Promise.resolve(&#123; // ... 组件定义对象&#125;)// 引用组件，Babel需要添加 syntax-dynamic-import解析语法const Foo = () =&gt; import('./Foo.vue')const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo &#125; ]&#125;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native性能优化与重绘机制]]></title>
    <url>%2F2019%2F02%2F16%2Freact-native-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[减少重绘和并发执行实现 减少不必要的setState setState是用来改变数据，触发视图更新的方法，调用setState会触发组件重绘。在复杂组件中setState会触发整个组件包括其子组件的重绘，这个是导致渲染进程被阻塞的主要原因。因此，应尽量细化组件，在必要的子组件中执行setState，减少在复杂组件中setState带来的重绘成本。 setNativeProps更新属性 用原生属性更新setNativeProps的方法去替代setState。一些样式属性上的切换和变化，可以用setNativeProps去更新，从而减少重绘。 shouldComponentUpdate减少不必要的重绘在组件shouldComponentUpdate周期，即重绘render前，判断组件state和props的数据变化，没有变化则不执行重绘。Immutable.js判断复合类型的变化 PureComponent组件 组件的setState如果只有非对象数据类型的变化，可以用PureComponent，不会根据父组件的重绘而导致自身重绘。 减少动画时执行阻塞组件初始化后，利用InteractionManager使数据请求在动画完成后再执行，减少js线程和掉帧现象，避免切换组件时动画卡顿和延迟，但是同时会延迟了数据请求，会导致再次渲染。 提前获取数据，减少渲染组件渲染慢的问题，像个人中心，好友列表等，在进入页面前先把数据加载完毕，在组件初始化的时候赋值state数据，使组件先获得数据，只渲染一次。（若在组件渲染完之后，再获取数据，会再次渲染）与第5点是矛盾的，可以根据进入导航的交互体验去取舍。 组件生命周期及重绘机制组件的三种状态及生命周期函数： 挂载阶段 Mounting componentWillMount：组件挂载之前执行，在render之前调用 componentDidMount： 组件渲染完成，在所有子组件都render完之后调用 组件变化 Updating componentWillUpdate：组件将要重新渲染 componentDidUpdate：组件重新渲染完成 卸载阶段 UnMounting componentWillUnmount: 卸载组件 两种特殊状态的处理函数 componentWillRecevieProps：组件将要接收新的props时执行 shouldComponentUpdate(nextProps, nextState)：判断组件是否应该重新渲染，默认是true setState执行时，一般会触发组件视图重绘。 前后不改变state值 和 无数据交换的父组件的重渲染 的 setState 都会导致组件的重复渲染 组件的功能细分与dom差异化重绘成本有关。 重绘步骤 react重新构建虚拟dom树。 与上一个虚拟dom树对比diff，得出dom结构的差异。 对发生变化的组件进行重绘。 判断setState没有发生变化时，执行return false可阻止不必要的渲染 Immutable.is() / lodash _.isEqual() 判断复合类型的数据变化 复合类型的数据变化比较Immutable.is() 实现 123456import &#123; is &#125; from 'immutable';shouldComponentUpdate: (nextProps = &#123;&#125;, nextState = &#123;&#125;) =&gt; &#123; return !(this.props === nextProps || is(this.props, nextProps)) || !(this.state === nextState || is(this.state, nextState));&#125; 性能Immutable使用Structural Sharing（结构共享）比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。 减少内存 避免了深度遍历比较，便于比较复杂数据 lodash _.isEqual() 实现 123456shouldComponentUpdate (nextProps, nextState) &#123; if (_.isEqual(this.state, nextState) &amp;&amp; _.isEqual(this.props, nextProps)) &#123; return false &#125; return true&#125; lodash _isEqual() 思路 同数据类型 数组 equalArrays 数组长度 set关联 对象 equalObject key属性名 value值 constructor是否相同 其他类型 equalByTag Buffer Boolean、Date、Number，通过+value转化为0、1比较 error 比较error.name &amp;&amp; error.message regExp、string，转化为string比较 map、set，转化为array，equalArrays 不同类型 -&gt; false 性能_isEqual 对象层级越深，越耗时 diff算法 tree diff dom tree分层级 稳定dom的结构有利于提高新能，应尽量减少dom频繁的移除或添加 component diff 同一类型组件 v-dom变化 tree diff v-dom不变，使用shouldComponentUpdate判断是否进行重绘，提高性能 不同类型组件 dirty component，替换整个组件下的子节点 element diff 插入节点、移动节点、移除节点 同一层级的子节点添加唯一key值进行区分，通过key值判断集合中是否存在相同的节点，以此判断对节点的更新：移动或增删，是否可复用元素 避免大量节点拖拽排序 资料资料2 触发重绘步骤 资料react+redux+immutablejs 减少新建变量事件绑定this 1234567891011121314handleClick = () =&gt; &#123; // 属性初始化 console.log('this is:', this);&#125;&lt;button onClick=&#123;this.handleClick&#125;&gt;btn1&lt;/button&gt; // 每次render只执行一次handleClick (id, e) &#123; console.log('this is:', this); // 若不绑定this,会返回undefined&#125;&lt;button onClick=&#123;(e) =&gt; this.handleClick(id, e)&#125;&gt;btn2&lt;/button&gt; // 每次渲染都创建新的的箭头函数，可用作事件回调传参，但不建议用作props传入组件中，会带来不必要的渲染&lt;button onClick=&#123;this.handleClick.bind(this, id)&#125;&gt;btn3&lt;/button&gt; // 每次render重新执行&lt;Foo style=&#123;&#123; color: "red" &#125;&#125;/&gt; // 每一次渲染都被认为 props 发生变化const fooStyle = &#123; color: "red" &#125;&lt;Foo style=&#123;btnStyle&#125;/&gt; // 同一个引用，props没有发生变化 组件更新优化 单个组件更新：避免父节点类型随意更改 组件列表，key优化：key是唯一且稳定不变的，避免用数组index作为key redux性能优化：reselect实现原理：只要相关的状态不变，就直接用上一次缓存的结果资料]]></content>
      <tags>
        <tag>react-native</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rn-app更新的realm数据迁移]]></title>
    <url>%2F2019%2F02%2F16%2Frealm%2F</url>
    <content type="text"><![CDATA[realm 数据迁移12345678910111213141516static db = new Realm(&#123; path: 'db.realm', schema: tableList, // 数据表配置 // 版本号：如果本地表格修改了，可以通过这个参数进行迭代更新 schemaVersion: 2, migration: (oldRealm, newRealm) =&gt; &#123; if (oldRealm.schemaVersion &lt; 2) &#123; // 数据表迁移内容，与新版本兼容 Util.devLog('migration realm') let oldObj = oldRealm.objects('recentGame') let newObj = newRealm.objects('recentGame') for (var i = 0; i &lt; oldObj.length; i++) &#123; newObj[i].id = i; &#125; &#125; &#125;&#125;); realm 本地储存操作使用教程 apiapi]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native常用基础布局总结]]></title>
    <url>%2F2019%2F02%2F16%2Freact-native-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[多个style1style=&#123;[styles.style1, styles.style2]&#125; 组件组件之间的属性/事件传递 父子组件 porps http://blog.csdn.net/p106786860/article/details/52408875 兄弟组件事件传递 DeviceEventEmitter http://blog.csdn.net/slowlifes/article/details/75330862 组件使用api常用组件 FlatList 列表 自带滚动 scrollView，设置上下间距无效，需要设置到子元素的view contentContainerStyle 样式应用到内层容器 onRefresh 需要 与 refreshing 共用 onScroll event参数 event.nativeEvent.contentOffsetY 滚动垂直距离 event.nativeEvent.layoutMeasurement.height 滚动内容高度 numColumns={3} 三列、横行排列 horizonal={true} 始终横向排列，超出范围横向滚动 1234567&lt;FlatList data=&#123;this.state.userList&#125; keyExtractor=&#123;this.keyExtractor&#125; renderItem=&#123;this.renderItem&#125; style=&#123;styles.container&#125; numColumns=&#123;3&#125; /&gt; 尺寸 屏幕尺寸与大小适配 px转化为dp rn单位问题换算 ppi像素密度 ppi / 160dp 与 px 的关系 123456789dp = px / (ppi / 160)px = dp * ppi / 160dp = px / PixelRatio.get()// 设计稿// 4.7英寸，分辨率1136*640，那么像素密度是：√（1136^2+640^2）=1303.87// 1303.87/4.7≈277ppi// 像素密度 = 277 / 160 = 1.73 [app 设计详细]http://www.25xt.com/appdesign/8862.html 手势、点击穿透pointerEvent 控制组件与子组件之间的触摸关系 图片 网络图片需要预设一个固定宽高，否则大小为0 gif图支持android/app/build_gradle 123dependencies// For animated GIF supportcompile &apos;com.facebook.fresco:animated-gif:0.13.0&apos; 圆角图片溢出（有锯齿） overflow: ‘hidden’安卓中无效，子级元素会溢出 防止圆角图片溢出：添加父级View作溢出处理（父级为设置了borderRadius的View） zIndexopacity属性会影响溢出显示的元素的层次顺序，因此可以用在子元素上zIndex不一定有效，最好是通过元素顺序来控制层次 滚动事件 onScrollBeginDrag onScrollEndDrag onMomentumScrollBegin onMomentumScrollEnd onScroll 滚动导航置顶 滚动列表的高度需要固定（置顶前高度=屏幕高度），否则会因为导航置顶，滚动内容高度变化造成闪烁 动画，interpolate 插值 点击涟漪反馈 支持android api 21+ MRN 基于React Native的Material Design风格的组件库 支持android api 16+ 1234&lt;TouchableNativeFeedbackbackground=&#123; (Platform.OS === &apos;android&apos; &amp;&amp; Platform.Version &gt;= 21) ? TouchableNativeFeedback.Ripple(&apos;#ccc&apos;, false) : null &#125; // 满足安卓平台及api 21+onPressOut=&#123;this.onPressEvent.bind(this, item)&#125; delayPressOut=&#123;100&#125;&gt; // 点击先执行涟漪动画，再执行press事件，防止事件响应过不显示涟漪动画&lt;/TouchableNativeFeedback&gt; 动画教程loop动画在组件销毁前最好先stop 字体过长处理ellipsizeMode=’tail’ numberOfLines={1} 用ts编写rn教程 参考：布局篇详解样式使用与 flexbox]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native热更新与打包发布]]></title>
    <url>%2F2019%2F02%2F16%2Freact-native-%E7%83%AD%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[打包配置确认流程 config.js版本号 与 环境 bundleMinVersion + 1 测试环境release包 与 正式环境release包 对应环境域名 配置热更新服务器环境，区分环境，nativeConfig.js -&gt;buildConfig.DEBUG ? “http://**-test.com:3000” : “http://**-pro.com:3000” 热更新服务器登录切换 code-push whoami测试环境 http://**-test.com:3000正式环境 http://**-pro.com:3000 run-android发布12react-native run-android // debug包 react-native run-android --variant=release // release包 生成bundle包123456789react-native bundle --platform android --entry-file index.js --bundle-output ./bundles/index.android.bundle --assets-dest ./bundles --dev false// 解释react-native bundle--platform android // 平台--entry-file index.js //启动文件--bundle-output ./bundles/index.android.bundle // 打包js输出文件--assets-dest ./bundles // 资源输出目录--dev true // 是否调试模式 调试环境 –dev true；正式环境 –dev false 提交bundle包到code-push，发布更新 获取登录的tokenhttp://**-test.com:3000用户名：admin密码：** 登录到code-push-server 1code-push login http://******-test.com:3000 token 复制 1）中获取的 token code-push相关命令查看 appcode-push app ls查看 Deployment Key code-push deployment ls 组局游戏-android -k 执行code-push release命令 12345678910code-push release "组局游戏-android" ./bundles/ 0.0.3 --deploymentName Production --description "version=8" --mandatory false// 解释code-push release"组局游戏-android" // &lt;应用名称&gt;./bundles/ // &lt;bundle所在目录&gt;1.0.0 // &lt;对应版本&gt;--deploymentName Staging // 更新环境 Staging 测试环境 Production 正式环境--description "For test bundle_version=3" // 更新描述--mandatory false //是否强制更新 12code-push history deployment "组局游戏-android" Production // 查看历史版本code-push deployment clear "组局游戏-android" Production // 清除版本 参考 混淆代码启用Proguard代码混淆来缩小APK文件的大小 1def enableProguardInReleaseBuilds = true api]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-native实现多台真机调试]]></title>
    <url>%2F2019%2F02%2F16%2Freact-native-%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[调试工具react-devtools与 模拟器中ctrl+m 的 toggle inspector 结合使用，可以调试元素的 props、state、style 多台真机调试 有线 1234567react-native run-android // 有线连接一台设备，并输出// 或adb logcat *:S ReactNative:V ReactNativeJS:Vadb devices // 输出设备列表，有线连接多台设备，并指定设备号输出logadb -s ca759657 logcat -v threadtime *:S ReactNative:V ReactNativeJS:Vadb -s e5a56695 logcat -v threadtime *:S ReactNative:V ReactNativeJS:V 无线install apkDev Settings -&gt; Debug server host &amp; post for device -&gt; 本机ip:8081（同一局域网） log打印12react-native log-android（相当于adb logcat，用于有线连接）adb logcat *:S ReactNative:V ReactNativeJS:V 指定设备输出log：12adb -s ca759657 logcat -v threadtime *:S ReactNative:V ReactNativeJS:Vadb -s e5a56695 logcat -v threadtime *:S ReactNative:V ReactNativeJS:V chrome控制台调试：Dev Settings -&gt; Debug js remotely （同一局域网内可无线连接）热加载：Dev Settings -&gt; Enable Live Reloading, Enable Hot Reloading 参考 防止控制台输出中文乱码 乱码原因：Android中使用的是UTF-8字符，而CMD默认字符集是ANSI，中文环境下即为GBK。 查看当前编码 12chcp// Active code page: 936 更改代码页 12chcp 65001// Active code page: 65001 更改字体设置cmd.exe 右键 -&gt; 属性 -&gt; 字体把字体从点阵字体更改为”Lucida Console”字体大小调到14 参考1参考2]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native运行的build_gradle配置]]></title>
    <url>%2F2019%2F02%2F16%2Fbuild-gradle-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071apply plugin: 'com.android.application'//说明module的类型，com.android.application为程序，com.android.library为库android &#123; compileSdkVersion 22//编译的SDK版本 buildToolsVersion "22.0.1"//编译的Tools版本 defaultConfig &#123;//默认配置 applicationId "com.nd.famlink"//应用程序的包名 minSdkVersion 8//支持的最低版本 targetSdkVersion 19//支持的目标版本 versionCode 52//版本号 versionName "3.0.1"//版本名 &#125; sourceSets &#123;//目录指向配置 main &#123; manifest.srcFile 'AndroidManifest.xml'//指定AndroidManifest文件 java.srcDirs = ['src']//指定source目录 resources.srcDirs = ['src']//指定source目录 aidl.srcDirs = ['src']//指定source目录 renderscript.srcDirs = ['src']//指定source目录 res.srcDirs = ['res']//指定资源目录 assets.srcDirs = ['assets']//指定assets目录 jniLibs.srcDirs = ['libs']//指定lib库目录 &#125; debug.setRoot('build-types/debug')//指定debug模式的路径 release.setRoot('build-types/release')//指定release模式的路径 &#125; signingConfigs &#123;//签名配置 release &#123;//发布版签名配置 storeFile file("fk.keystore")//密钥文件路径 storePassword "123"//密钥文件密码 keyAlias "fk"//key别名 keyPassword "123"//key密码 &#125; debug &#123;//debug版签名配置 storeFile file("fk.keystore") storePassword "123" keyAlias "fk" keyPassword "123" &#125; &#125; buildTypes &#123;//build类型 release &#123;//发布 minifyEnabled true//混淆开启 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-project.txt'//指定混淆规则文件 signingConfig signingConfigs.release//设置签名信息 &#125; debug &#123;//调试 signingConfig signingConfigs.release &#125; &#125; packagingOptions &#123; exclude 'META-INF/ASL2.0' exclude 'META-INF/LICENSE' exclude 'META-INF/NOTICE' exclude 'META-INF/MANIFEST.MF' &#125; lintOptions &#123; abortOnError false//lint时候终止错误上报,防止编译的时候莫名的失败 &#125; &#125; dependencies &#123; compile fileTree(dir: 'libs', exclude: ['android-support*.jar'], include: ['*.jar']) //编译lib目录下的.jar文件 compile project(':Easylink')//编译附加的项目 compile project(':ImageLibrary') compile project(':ImageResLibrary') compile project(':Ofdmtransport') compile project(':PullToRefreshLibrary') compile project(':RecorderLibrary') compile project(':WebSocket') compile project(':WidgetLibrary') compile 'com.nostra13.universalimageloader:universal-image-loader:1.9.3'//编译来自Jcenter的第三方开源库&#125; 参考]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native运行步骤及记录一些坑]]></title>
    <url>%2F2019%2F02%2F16%2Freact-native-%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[build.gradle 配置android/app/build.gradle 12345678910111213141516android &#123; // 对应版本 compileSdkVersion 24 buildToolsVersion "24.0.2" // D:\Windows\Android\sdk\build-tools // 查看版本 defaultConfig &#123; applicationId "com.awesomeproject" minSdkVersion 16 targetSdkVersion 24 versionCode 1 versionName "1.0" ndk &#123; abiFilters "armeabi-v7a", "x86" &#125; &#125;&#125; 1234567dependencies &#123; compile fileTree(dir: "libs", include: ["*.jar"]) compile "com.android.support:appcompat-v7:24.2.1" // D:/Windows/Android/sdk/extras/android/m2repository/com/android/support/appcompat-v7/ compile "com.facebook.react:react-native:+" // From node_modules&#125; 运行 真机运行 【推荐】 与虚拟器中运行的兼容性不同，以真机为准 adb adb devices 检测真机是否连接成功 adb shell input keyevent 82 调起任务栏 或 虚拟器运行 Genymotion 【推荐】 偶尔启动失败问题：升级VirtualBox版本 自带的 Android Device Emulator（配置比较多坑） 1234adb devices // 打印设备列表，确保设备已连接npm install // 添加包含原生代码的库react-native link // 根据package.json中的依赖链接原生库react-native run-android // 运行项目 运行中遇到的坑版本报错：build_gradle对应版本 / 依赖库中的最低版本依赖 解决： 升级到依赖库中的最低版本，并确保sdk版本已安装 连接设备报错could not get BatchedBridge 1could not get BatchedBridge, make sure your bundle is packaged correctly 解决： 12adb devices // 输出设备列表，模拟器adb reverse tcp:8081 tcp:8081 真机设置 dev setting -&gt; debug server host for device -&gt; localhost:8081 fbBatchedBridge is undefined 1failed to call funciton, __fbBatchedBridge is undefined 解决： 保证电脑和app启动在同一个局域网下，指定本机ip地址和端口号 12345// 项目根目录，--host为本机ip地址react-native start --host 10.1.102.80 --port 8081// 另一个控制台react-native run-android 模块安装报错：can’t delete / create path 1Error: Cannot create directory E:\react-native-JueJinClient-master1\android\app\build\intermediates\merged.dir\values 解决： 1cd android &amp;&amp; gradlew clean 依赖库版本报错：min-sdk-version&gt;=26 解决： lottie-react-native 应用方法数报错 build.gradle 12345678android &#123; defaultConfig &#123; multiDexEnabled = true &#125;&#125;dependencies &#123; compile 'com.android.support:multidex:1.0.1'&#125; 添加依赖 123import android.support.multidex.MultiDexApplication;public class MainApplication extends MultiDexApplication implements ReactApplication 混淆报错：release 报错 proguard 1unable to process incoming event 'ProcessComplete' &lt;ProgressCompleteEvent&gt; 解决： 1cd android &amp;&amp; gradlew.bat assembleRelease --console plain // 查找原因 思路： 新功能单独打包，排查是否是库文件混淆问题。是，则查找库文件相关的混淆规则；否，则查看项目源码中更改的地方，并加上相应的混淆规则。 相关库是否需要加上混淆的规则 如在库的github中查找 用android studio打包，可以查看具体出错的类 添加规则 12345# react-native-webrtc-keep class org.webrtc.** &#123;*;&#125;-dontwarn org.webrtc.**-keep class org.chromium.** &#123;*;&#125;-dontwarn org.chromium.** 如果还是报错，尝试提高库文件的sdk版本 1234567891011121314android &#123; compileSdkVersion 26 buildToolsVersion "26.0.3" defaultConfig &#123; minSdkVersion 16 targetSdkVersion 23 versionCode 1 versionName "1.0" ndk &#123; abiFilters "armeabi-v7a", "x86" &#125; &#125;&#125; Chrome调试报错1 Attempted to transition from state `RESPONDER_INACTIVE_PRESS_IN` to `RESPONDER_ACTIVE_LONG_PRESS_IN`, which is not supported. This is most likely due to `Touchable.longPressDelayTimeout` not being cancelled 解决：开启Debug JS Remotely模式下chrome调试，使用TouchableHighlight会出现以上报错，建议关闭Chrome调试或重启apk build时间比较长的问题 原因：依赖的库的云下载时间长 build一次后，android/app/build 生成，第一次生成build的时间会比较长 再次执行build前，删除以下文件夹android\app\build\generatedandroid\app\build\intermediates\classesandroid\app\build\intermediates\incremental 如果报错 can’t delete node_modules其他库的build子文件夹，执行 cd android &amp;&amp; gradlew clean 其他命令 1234567cd android &amp;&amp; gradlew clean // 清除所有的构建任务的output，包含apk文件gradlew check // 执行Lint检查并且能够在Lint检测到错误后停止运行gradlew build // 执行assemble和checkgradlew connectedCheck // 在测试机上执行所有测试任务gradlew deviceCheck // 执行所有在远程设备上的测试任务gradlew installDebuggradlew installRelease // 在设备上安装一个Debug/Release版本]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native安装与环境搭建]]></title>
    <url>%2F2019%2F02%2F16%2Freact-native-%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装前 注意：不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别！ Python 2 打开 PowerShell 窗口 win+r -&gt; PowerShell -&gt; enter 安装 chocolatey，并设置环境变量 1@powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 安装 python2 1choco install python2#main java 安装 jdk-8u101-windows-x64 或 choco install jdk8 设置环境变量 JAVE_HOME E:\Program Files\Java\jdk1.8.0_101 CLASSPATH .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; PATH %JAVA_HOME%\bin android studio 安装选择 Android Support Repository Android SDK Android Device Emulator 模拟器（配置较多，推荐Genymotion） HAXM加速驱动 环境变量 ANDROID_HOME D:\Windows\Android\sdk PATH D:\software\AndroidSdk\tools\;D:\software\AndroidSdk\platform-tools\; Android SDK的tools目录，以便在终端运行一些android工具：android avd、adb logcat 等 react-native-cli 全局安装 rn 脚架 1npm install -g react-native-cli react-native 初始化项目 1react-native init AwesomeProject 推荐安装 模拟器工具 Genymotion 提高编译速度 Gradle Daemon安装1(if not exist "%USERPROFILE%/.gradle" mkdir "%USERPROFILE%/.gradle") &amp;&amp; (echo org.gradle.daemon=true &gt;&gt; "%USERPROFILE%/.gradle/gradle.properties") ps: api]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react基础]]></title>
    <url>%2F2019%2F02%2F16%2Freact-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JSX 在react中使用jsx来 描述用户界面 jsx中的表达式 {} 在语句中使用jsx 属性 “” 属性表达式 {} 防xss攻击 元素渲染 元素，react应用的最小单位 ReactDOM.render() 更新元素：只更新改变的部分 组件和props 组件定义 12345678910// es6 class 定义 react 组件class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;// 或 函数定义 react 组件function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 组件渲染 12// 组件渲染const element = &lt;Welcome name="Sara" /&gt;; // 组件名称首字母大写 注意： 组件名称首字母大写 组件的返回值只能有一个根元素 state 和 生命周期 组件更新 -&gt; 添加状态 函数转变为类 -&gt; 添加局部状态、生命周期钩子 属性转变为 局部状态： this.props.date -&gt; this.state.date 类构造函数 this.state 传递props到基础构造函数 生命周期方法添加到类： 组件第一次加载到dom，挂载 componentDidMount 组件生成的dom被移除，卸载 componentWillUnmount 状态更新，位于事件处理器中的setState是异步的 redux 状态管理 123this.setState((preState, props) =&gt; &#123; counter: this.state.counter + props.increment // 属性中的增量&#125;) 在事件循环中，状态更新合并 事件处理 添加监听器 1onClick = &#123;handleClick&#125; preventDefault 阻止默认行为 react事件绑定this 构造函数中绑定this（官方推荐，只会生成一次实例） 使用属性初始化器语法 在调用时使用箭头函数绑定this 1234567891011121314151617181920212223242526272829// 构造函数中绑定thisconsructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125; this.handleClick = this.handleClick.bind(this)&#125;handleClick () &#123; console.log('this', this)&#125;&lt;button onClick=&#123;this.handleClick&#125;&gt; Click me&lt;/button&gt;// 属性初始化器语法，es6handleClick = () =&gt; &#123; console.log(this); &#125;// 在添加监听器的 回调函数中 使用箭头函数（如果回调函数作为一个属性值传入低阶组件，组件可能会进行额外的重新渲染，建议用1、2）handleClick () &#123; console.log(this)&#125;render () &#123; return ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; click &lt;button&gt; )&#125; react事件传参，会造成额外渲染 123&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;!--deleteRow(id, e) 事件对象e放后面--&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 条件渲染 if &amp;&amp; ? : return null 阻止组件渲染 列表 数组转化为数列元素 123456789101112131415function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;number&#125;&lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 表单 受控组件 input、select、textarea checkBox 1234567891011121314this.state = &#123;value: ''&#125;;handleChange(event) =&gt; &#123; this.setState(&#123;value: event.target.value.toUpperCase()&#125;);&#125;// 渲染表单&lt;input type="text" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;&lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;&lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value="grapefruit"&gt;Grapefruit&lt;/option&gt; &lt;option value="lime"&gt;Lime&lt;/option&gt; &lt;option value="coconut"&gt;Coconut&lt;/option&gt; &lt;option value="mango"&gt;Mango&lt;/option&gt;&lt;/select&gt; 状态提升状态分享，将state数据 提升至 离他们最近的父组件中进行管理私有state，handleChange -&gt; 转化为 父组件props api]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js模块化——AMD与CMD的区别]]></title>
    <url>%2F2019%2F02%2F15%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言模块系统 定义封装的模块 管理模块之间的依赖关系 引入模块 AMD 异步模块定义特点 提前执行依赖模块，预加载 推崇依赖前置 requireJs require.config() 模块加载自定义 require_conf.js 一个文件一个模块 加载规范化模块 define()定义 加载非规范化的模块，如jquery define() 模块定义 id 模块标识 dependencies模块依赖 factory 实例化函数/对象 r.js 合并与压缩模块文件 build.js 打包配置文件 node r.js -o build.js12345678910111213141516171819// 独立模块define(&#123; add: function (x) &#123; return x &#125;&#125;)// 非独立模块define(['alpha'], function (alpha) &#123; return &#123; add: function (x) &#123; return x &#125; &#125;&#125;)// 包装模块，暴露apidefine(function(require, exports, module) &#123; var base = require('base') // 兼容commonJs写法，但仍然是提前加载 var export = &#123; add: addFun &#125; function addFun () &#123;&#125; return export&#125;) r.js配置参数 123456789101112131415161718192021222324252627282930313233343536(&#123; appDir: './', // 应用程序目录 baseUrl: './js', // js的相对目录 dir: './dist', // 输出目录 modules: [ // 一个包含多个对象的数组，模块 &#123; name: 'main' &#125; ], fileExclusionRegExp: /^(r|build)\.js$/, // 排除规则 optimizeCss: 'standard', removeCombined: true, // 输出目录中删除已合并的文件 paths: &#123; // 模块的相对目录 jquery: 'lib/jquery', underscore: 'lib/underscore', backbone: 'lib/backbone/backbone', backboneLocalstorage: 'lib/backbone/backbone.localStorage', text: 'lib/require/text' &#125;, shim: &#123; // 非规范定义的模块 underscore: &#123; exports: '_' &#125;, backbone: &#123; deps: [ 'underscore', 'jquery' ], exports: 'Backbone' &#125;, backboneLocalstorage: &#123; deps: ['backbone'], exports: 'Store' &#125; &#125;&#125;) api) CMD 公共模块定义特点 延迟执行依赖模块，按需加载，懒加载 推崇依赖就近 同步加载，文件加载完才能执行操作 seaJs1234567define(function(require, export, module) &#123; var a = require('./a') // 软依赖 if (status) &#123; var b = require('./b') &#125;&#125;) commonJs 同步加载，文件加载完才能执行操作 服务端模块规范 node，webpack通过commonJs规范实现 定义模块 require 引入模块 exports 导出当前模块属性 module 模块 1234567891011//file1.jsmoudle.exports = &#123; a: 1&#125;;//file2.jsvar f1 = require('./file1');var v = f1.a + 2;module.exports =&#123; v: v&#125;; UMD 通用模块定义 AMD和commonJs的糅合，解决跨平台问题 1234567891011(function (window, factory) &#123; if (typeof exports === 'object') &#123; module.exports = factory(); // 支持node模块则使用commonJs &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(factory); // amd 方式加载 &#125; else &#123; // 都不是，全局定义 window.eventUtil = factory(); &#125;&#125;)(this, function () &#123; // module ...&#125;);]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css命名规范——NEC与BEM]]></title>
    <url>%2F2019%2F02%2F15%2Fcss%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[命名方式NEC网易CSS方案：NEC CSS内部的分类及其顺序： 重置（reset）和默认（base）（tags）消除默认样式和浏览器差异，并设置部分标签的初始样式，以减少后面的重复劳动 统一处理建议在这个位置统一调用背景图（这里指多个布局或模块或元件共用的图）和清除浮动（这里指通用性较高的布局、模块、元件内的清除）等统一设置处理的样式 布局 grid（g-）将页面分割为几个大块，如头部、尾部、主体、侧栏等 模块 module（m-）较大整体，如导航、登录注册、列表、评论、搜索等 元件 unit（u-）不可再分个体，如按钮、input、loading、图标等 功能 function（f-）使用率较高的样式，如清除浮动等 皮肤 skin（s-）如文字色、背景色（图）、边框色等 状态（z-）如hover，选中等 BEMYandex的CSS命名方法论：BEM 块.block，更高级别的抽象或组件 元素.block__element，块的后代元素 修饰符.block–modifier，块的不同状态或版本 两者结合使用可以避免使用BEM导致css命名冗长使用NEC区分出元件后，再对元件使用BEM命名模式 如： g_header，g_footer，g_main，g_cont m_title u_title，u_title–2 m_drawListu_item，u_item–0，u_drawbg，u_drawName，u_img]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node版本管理工具——nvm]]></title>
    <url>%2F2019%2F02%2F15%2Fnode-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[nvm —— node 版本管理 先卸载原来的node 下载nvm github download 安装 注意安装路径不能有空格 NVM环境变量的用户和系统变量要与setting.txt设置的路径一致 命令123nvm install versionnvm lsnvm user version]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序登录流程]]></title>
    <url>%2F2019%2F02%2F13%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[客户端 &lt;open-data&gt; 组件，可直接获取基本的用户数据 需要登录的接口 -&gt; buildHeader 无code：wx.login 获取code 有code：headers 设置 wx_code 授权回调 -&gt;userInfo 定期wx.checkSession检测 session_key 是否过期 wx.request 发送code到服务端 x-check-login 用于判断是否需要登录校验 服务端 是否需要登录校验 根据code 进行 jscode2session 登录校验 -&gt; 没有code checkUser _user 一些概念 code 临时登录凭证（有效期五分钟，只能使用一次） client: wx.login() -&gt; code header 封装自定义登录态（用于需要静默登录的接口） X-Wx-Code: code X-Wx-Rawdata: random User-Agent: token client: wx.request(avatar、nickname) -&gt; openid appid 小程序唯一标识、appsecret 小程序密钥 session_key 会话密钥（对用户数据进行加密签名）、openid 用户唯一标识 server: code + appid + appsecret -&gt; jscode2session -&gt; openid、session_key、unionid jscode2session 登录凭证校验接口 3rd_session unioinid 用户在微信开放平台的唯一标识。 同一个用户，在同一个微信开放平台下的不同应用，unionid是相同的 云函数 cloud.getWXContext 获取 unionId accessToken 后台接口调用凭证 server: appid + appsecret -&gt; getAccessToken getAccessToken 参考api]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强缓存与协商缓存的区别及缓存优化]]></title>
    <url>%2F2019%2F02%2F13%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[前言url请求过程中，浏览器会根据缓存机制保存请求的资源。当浏览器再次请求相同的url时，会根据header标识判断是否使用缓存。强缓存是浏览器本地缓存，根据缓存的cache-control和expires判断资源是否过期，未过期则不经过服务器请求，返回200。协商缓存根据Etag和Last-modified判断是否有数据更新，是则读取浏览器缓存，更新请求header并返回304；否则经过服务器请求，返回200，更新数据和请求header。 第一次请求： 第二次请求： 强缓存（本地缓存）1、特点 不发送请求到服务器 返回 200 from cache from memory cache 内存中读取 关闭页面随内存释放 js、font、img from disk cache 硬盘中读取 不会随页面关闭而释放 css（加载一次 disk -&gt; memory） 2、header字段 Cache-control : max-age=number（优先）http1.1 no-cache 不是用本地缓存 no-store 禁止缓存 public 可被所有用户缓存：终端用户的浏览器、CDN等中间代理服务器 private 终端用户的浏览器 Expires : GMT http1.0 GMT &gt; 发送请求的时间 协商缓存（由服务器决定）1、特点 返回 304，not modified 通过服务器告知缓存可用 更新header信息，不更新返回数据 header报文大小 2、header字段 Etag/If-None-Match：string（优先） http1.1 资源唯一标识符，资源变化会更新 优点：更准确的控制缓存 精确到秒以下的粒度 内容不变，修改时间变化的情况下使用缓存 Last-modified/If-Modified-Since: GMT GMT 最后修改时间 == 资源在服务器最后修改时间 == 304 not modified，不返回资源内容，response header更新 != 200，重新加载资源，header Last-modified更新 缓存优化1、三级缓存原理 内存 ↓ （强缓存） 硬盘 ↓ （强缓存） 网络请求 ↓ 200 请求 304 （协议缓存，只更新header） 缓存到硬盘和内存 2、缓存优化思路 200 -&gt; 304 -&gt; 本地缓存 更新url版本号，使浏览器重新请求资源 文件级别的精确缓存控制 文件内容变化才变更url 将url改成带 文件摘要信息 静态资源CDN节点部署 性能优化：静态资源和动态网页分集群部署，静态资源部署到CDN节点 覆盖式发布：部署页面和部署资源的先后顺序：资源 -&gt; 页面 非覆盖式发布 用文件摘要信息 对资源文件进行重命名，不覆盖原有的资源文件 全量部署静态资源，再灰度部署页面 3、静态资源缓存控制方案 配置超长时间的本地缓存：节省带宽 提高性能采用内容摘要作为缓存更新依据：精确的缓存控制 静态资源CDN部署： 优化网络请求 更新资源发布路径实现非覆盖式发布： 平滑升级 ps：from 大公司的缓存优化 4、实现工具rails assets pipelineF.I.S F.I.S发布项目]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件机制之事件冒泡与事件捕获]]></title>
    <url>%2F2019%2F02%2F10%2F%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[前言dom事件流的三个阶段： 事件捕获阶段 capturing：从外到里进行事件传播，从根节点开始 目标阶段 事件冒泡阶段 bubbling：从里到外进行事件传播，直到根节点 触发dom事件时，先进行事件捕获 外-&gt;里，捕获到事件源之后通过事件传播，再进行事件冒泡 里 -&gt; 外。 事件绑定 addEventListener(event, listener, userCapture)（ie11及以上，支持事件捕获） event: string listener: Function 事件监听函数 e.stopPropagation() 阻止事件冒泡到父元素 e.preventDefault() 阻止浏览器默认行为：如阻止href，input提交 e.stopImmediatePropagation() return false，包括 1 阻止冒泡 2 阻止默认行为 停止回调函数并立即返回 useCapture : boolean 默认为 false，采用事件冒泡的方式 true，采用事件捕获的方式 attachEvent(event, listener)（ie10及以下，不支持事件捕获） event listener 事件委托 一般用于动态生成的dom $(selector).on(event, childSelector, data, function, map) 通过父元素的事件绑定，判断目标元素是否为子元素]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码转换函数与uri、url区别]]></title>
    <url>%2F2019%2F02%2F10%2Furi%E4%B8%8Eurl%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[encodeURI() 用于整个 URI 的编码，不会对本身属于 URI 的特殊字符进行编码，如冒号、正斜杠、问号和井号； 不会进行编码的字符：ASCII字母、数字、~!@#$&amp;*()=:/,;?+’ 对应的解码函数 decodeURI() 类似escape()，但escape只针对字符串编码 encodeURIComponent() 用于对 URI 中的某一部分进行编码，会对它发现的任何非标准字符进行编码。 不会进行编码的字符：ASCII字母、数字、~!*()’ 对应的解码函数 decodeURIComponent() uri与url uri 统一资源标识符,是一个用于标识某一互联网资源名称的字符串 url 统一资源定位，是互联网上标准资源的地址]]></content>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
